// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const clearProjects = `-- name: ClearProjects :exec
DELETE FROM irontask.projects WHERE user_id = $1
`

func (q *Queries) ClearProjects(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearProjects, userID)
	return err
}

const clearTasks = `-- name: ClearTasks :exec
DELETE FROM irontask.tasks WHERE user_id = $1
`

func (q *Queries) ClearTasks(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearTasks, userID)
	return err
}

const createMagicLink = `-- name: CreateMagicLink :exec
INSERT INTO irontask.magic_links (email, token, expires_at)
VALUES ($1, $2, $3)
`

type CreateMagicLinkParams struct {
	Email     string    `json:"email"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateMagicLink(ctx context.Context, arg CreateMagicLinkParams) error {
	_, err := q.db.ExecContext(ctx, createMagicLink, arg.Email, arg.Token, arg.ExpiresAt)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO irontask.sessions (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING token
`

type CreateSessionParams struct {
	UserID    uuid.UUID `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.Token, arg.ExpiresAt)
	var token string
	err := row.Scan(&token)
	return token, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO irontask.users (username, email, password_hash)
VALUES ($1, $2, $3)
RETURNING id, username, email, created_at
`

type CreateUserParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

type CreateUserRow struct {
	ID        uuid.UUID    `json:"id"`
	Username  string       `json:"username"`
	Email     string       `json:"email"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Email, arg.PasswordHash)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM irontask.sessions WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const getMagicLink = `-- name: GetMagicLink :one
SELECT email, expires_at, used
FROM irontask.magic_links
WHERE token = $1
`

type GetMagicLinkRow struct {
	Email     string       `json:"email"`
	ExpiresAt time.Time    `json:"expires_at"`
	Used      sql.NullBool `json:"used"`
}

func (q *Queries) GetMagicLink(ctx context.Context, token string) (GetMagicLinkRow, error) {
	row := q.db.QueryRowContext(ctx, getMagicLink, token)
	var i GetMagicLinkRow
	err := row.Scan(&i.Email, &i.ExpiresAt, &i.Used)
	return i, err
}

const getProjectsChanged = `-- name: GetProjectsChanged :many
SELECT client_id, 'project' as type, sync_version, encrypted_data, deleted
FROM irontask.projects
WHERE user_id = $1 AND sync_version > $2
`

type GetProjectsChangedParams struct {
	UserID      uuid.UUID     `json:"user_id"`
	SyncVersion sql.NullInt64 `json:"sync_version"`
}

type GetProjectsChangedRow struct {
	ClientID      string        `json:"client_id"`
	Type          string        `json:"type"`
	SyncVersion   sql.NullInt64 `json:"sync_version"`
	EncryptedData []byte        `json:"encrypted_data"`
	Deleted       sql.NullBool  `json:"deleted"`
}

func (q *Queries) GetProjectsChanged(ctx context.Context, arg GetProjectsChangedParams) ([]GetProjectsChangedRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsChanged, arg.UserID, arg.SyncVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsChangedRow
	for rows.Next() {
		var i GetProjectsChangedRow
		if err := rows.Scan(
			&i.ClientID,
			&i.Type,
			&i.SyncVersion,
			&i.EncryptedData,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT user_id, expires_at
FROM irontask.sessions
WHERE token = $1 AND expires_at > NOW()
`

type GetSessionRow struct {
	UserID    uuid.UUID `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) GetSession(ctx context.Context, token string) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, token)
	var i GetSessionRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getTasksChanged = `-- name: GetTasksChanged :many
SELECT client_id, project_id, 'task' as type, sync_version, encrypted_data, deleted
FROM irontask.tasks
WHERE user_id = $1 AND sync_version > $2
`

type GetTasksChangedParams struct {
	UserID      uuid.UUID     `json:"user_id"`
	SyncVersion sql.NullInt64 `json:"sync_version"`
}

type GetTasksChangedRow struct {
	ClientID      string        `json:"client_id"`
	ProjectID     string        `json:"project_id"`
	Type          string        `json:"type"`
	SyncVersion   sql.NullInt64 `json:"sync_version"`
	EncryptedData []byte        `json:"encrypted_data"`
	Deleted       sql.NullBool  `json:"deleted"`
}

func (q *Queries) GetTasksChanged(ctx context.Context, arg GetTasksChangedParams) ([]GetTasksChangedRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksChanged, arg.UserID, arg.SyncVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksChangedRow
	for rows.Next() {
		var i GetTasksChangedRow
		if err := rows.Scan(
			&i.ClientID,
			&i.ProjectID,
			&i.Type,
			&i.SyncVersion,
			&i.EncryptedData,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash
FROM irontask.users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID           uuid.UUID `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email
FROM irontask.users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Email    string    `json:"email"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.Username, &i.Email)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash
FROM irontask.users
WHERE username = $1
`

type GetUserByUsernameRow struct {
	ID           uuid.UUID `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const markMagicLinkUsed = `-- name: MarkMagicLinkUsed :exec
UPDATE irontask.magic_links SET used = TRUE WHERE token = $1
`

func (q *Queries) MarkMagicLinkUsed(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, markMagicLinkUsed, token)
	return err
}

const upsertProject = `-- name: UpsertProject :one
INSERT INTO irontask.projects (user_id, client_id, name, color, encrypted_data, sync_version, deleted, updated_at)
VALUES ($1, $2, '', $3, $4, 
    (SELECT COALESCE(MAX(sync_version), 0) + 1 FROM irontask.projects WHERE user_id = $1), 
    $5, NOW())
ON CONFLICT (user_id, client_id) DO UPDATE
SET encrypted_data = EXCLUDED.encrypted_data,
    deleted = EXCLUDED.deleted,
    sync_version = (SELECT COALESCE(MAX(sync_version), 0) + 1 FROM irontask.projects WHERE user_id = $1),
    updated_at = NOW()
RETURNING sync_version
`

type UpsertProjectParams struct {
	UserID        uuid.UUID      `json:"user_id"`
	ClientID      string         `json:"client_id"`
	Color         sql.NullString `json:"color"`
	EncryptedData []byte         `json:"encrypted_data"`
	Deleted       sql.NullBool   `json:"deleted"`
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, upsertProject,
		arg.UserID,
		arg.ClientID,
		arg.Color,
		arg.EncryptedData,
		arg.Deleted,
	)
	var sync_version sql.NullInt64
	err := row.Scan(&sync_version)
	return sync_version, err
}

const upsertTask = `-- name: UpsertTask :one
INSERT INTO irontask.tasks (user_id, client_id, project_id, encrypted_data, deleted, sync_version, updated_at)
VALUES ($1, $2, $3, $4, $5, 
    (SELECT COALESCE(MAX(sync_version), 0) + 1 FROM irontask.tasks WHERE user_id = $1),
    NOW())
ON CONFLICT (user_id, client_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    encrypted_data = EXCLUDED.encrypted_data,
    deleted = EXCLUDED.deleted,
    sync_version = (SELECT COALESCE(MAX(sync_version), 0) + 1 FROM irontask.tasks WHERE user_id = $1),
    updated_at = NOW()
RETURNING sync_version
`

type UpsertTaskParams struct {
	UserID        uuid.UUID    `json:"user_id"`
	ClientID      string       `json:"client_id"`
	ProjectID     string       `json:"project_id"`
	EncryptedData []byte       `json:"encrypted_data"`
	Deleted       sql.NullBool `json:"deleted"`
}

func (q *Queries) UpsertTask(ctx context.Context, arg UpsertTaskParams) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, upsertTask,
		arg.UserID,
		arg.ClientID,
		arg.ProjectID,
		arg.EncryptedData,
		arg.Deleted,
	)
	var sync_version sql.NullInt64
	err := row.Scan(&sync_version)
	return sync_version, err
}
