// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING token
`

type CreateSessionParams struct {
	UserID    uuid.UUID `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.Token, arg.ExpiresAt)
	var token string
	err := row.Scan(&token)
	return token, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_hash)
VALUES ($1, $2, $3)
RETURNING id, username, email, created_at
`

type CreateUserParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

type CreateUserRow struct {
	ID        uuid.UUID    `json:"id"`
	Username  string       `json:"username"`
	Email     string       `json:"email"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Email, arg.PasswordHash)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const getProjectsChanged = `-- name: GetProjectsChanged :many
SELECT client_id, 'project' as type, sync_version, encrypted_data, deleted
FROM projects
WHERE user_id = $1 AND sync_version > $2
`

type GetProjectsChangedParams struct {
	UserID      uuid.UUID     `json:"user_id"`
	SyncVersion sql.NullInt64 `json:"sync_version"`
}

type GetProjectsChangedRow struct {
	ClientID      string        `json:"client_id"`
	Type          string        `json:"type"`
	SyncVersion   sql.NullInt64 `json:"sync_version"`
	EncryptedData []byte        `json:"encrypted_data"`
	Deleted       sql.NullBool  `json:"deleted"`
}

func (q *Queries) GetProjectsChanged(ctx context.Context, arg GetProjectsChangedParams) ([]GetProjectsChangedRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsChanged, arg.UserID, arg.SyncVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsChangedRow
	for rows.Next() {
		var i GetProjectsChangedRow
		if err := rows.Scan(
			&i.ClientID,
			&i.Type,
			&i.SyncVersion,
			&i.EncryptedData,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT user_id, expires_at
FROM sessions
WHERE token = $1 AND expires_at > NOW()
`

type GetSessionRow struct {
	UserID    uuid.UUID `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) GetSession(ctx context.Context, token string) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, token)
	var i GetSessionRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getTasksChanged = `-- name: GetTasksChanged :many
SELECT client_id, project_id, 'task' as type, sync_version, encrypted_data, deleted
FROM tasks
WHERE user_id = $1 AND sync_version > $2
`

type GetTasksChangedParams struct {
	UserID      uuid.UUID     `json:"user_id"`
	SyncVersion sql.NullInt64 `json:"sync_version"`
}

type GetTasksChangedRow struct {
	ClientID      string        `json:"client_id"`
	ProjectID     string        `json:"project_id"`
	Type          string        `json:"type"`
	SyncVersion   sql.NullInt64 `json:"sync_version"`
	EncryptedData []byte        `json:"encrypted_data"`
	Deleted       sql.NullBool  `json:"deleted"`
}

func (q *Queries) GetTasksChanged(ctx context.Context, arg GetTasksChangedParams) ([]GetTasksChangedRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksChanged, arg.UserID, arg.SyncVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksChangedRow
	for rows.Next() {
		var i GetTasksChangedRow
		if err := rows.Scan(
			&i.ClientID,
			&i.ProjectID,
			&i.Type,
			&i.SyncVersion,
			&i.EncryptedData,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID           uuid.UUID `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Email    string    `json:"email"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.Username, &i.Email)
	return i, err
}

const upsertProject = `-- name: UpsertProject :exec
INSERT INTO projects (user_id, client_id, name, color, encrypted_data, sync_version, deleted, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
ON CONFLICT (user_id, client_id) DO UPDATE
SET name = EXCLUDED.name,
    color = EXCLUDED.color,
    encrypted_data = EXCLUDED.encrypted_data,
    sync_version = EXCLUDED.sync_version,
    deleted = EXCLUDED.deleted,
    updated_at = NOW()
`

type UpsertProjectParams struct {
	UserID        uuid.UUID      `json:"user_id"`
	ClientID      string         `json:"client_id"`
	Name          string         `json:"name"`
	Color         sql.NullString `json:"color"`
	EncryptedData []byte         `json:"encrypted_data"`
	SyncVersion   sql.NullInt64  `json:"sync_version"`
	Deleted       sql.NullBool   `json:"deleted"`
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) error {
	_, err := q.db.ExecContext(ctx, upsertProject,
		arg.UserID,
		arg.ClientID,
		arg.Name,
		arg.Color,
		arg.EncryptedData,
		arg.SyncVersion,
		arg.Deleted,
	)
	return err
}

const upsertTask = `-- name: UpsertTask :exec
INSERT INTO tasks (user_id, client_id, project_id, encrypted_data, sync_version, deleted, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
ON CONFLICT (user_id, client_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    encrypted_data = EXCLUDED.encrypted_data,
    sync_version = EXCLUDED.sync_version,
    deleted = EXCLUDED.deleted,
    updated_at = NOW()
`

type UpsertTaskParams struct {
	UserID        uuid.UUID     `json:"user_id"`
	ClientID      string        `json:"client_id"`
	ProjectID     string        `json:"project_id"`
	EncryptedData []byte        `json:"encrypted_data"`
	SyncVersion   sql.NullInt64 `json:"sync_version"`
	Deleted       sql.NullBool  `json:"deleted"`
}

func (q *Queries) UpsertTask(ctx context.Context, arg UpsertTaskParams) error {
	_, err := q.db.ExecContext(ctx, upsertTask,
		arg.UserID,
		arg.ClientID,
		arg.ProjectID,
		arg.EncryptedData,
		arg.SyncVersion,
		arg.Deleted,
	)
	return err
}
